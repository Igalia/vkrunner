#!/usr/bin/env python

# Copyright (C) 2019 Intel Corporation

# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

# This script is used to generate features.rs from vulkan.h. It
# is not run automatically as part of the build process but if need be
# it can be used to update the file as follows:
#
# ./make-features.py < /usr/include/vulkan/vulkan_core.h > features.rs

import re
import sys
from mako.template import Template


EXTENSIONS = [
    "KHR_16BIT_STORAGE",
    "KHR_8BIT_STORAGE",
    {
        "name": "EXT_ASTC_DECODE_MODE",
        "struct": "VkPhysicalDeviceASTCDecodeFeaturesEXT",
        "struct_type": "ASTC_DECODE_FEATURES_EXT"
    },
    "EXT_BLEND_OPERATION_ADVANCED",
    "EXT_BUFFER_DEVICE_ADDRESS",
    "NV_COMPUTE_SHADER_DERIVATIVES",
    "EXT_CONDITIONAL_RENDERING",
    "NV_CORNER_SAMPLED_IMAGE",
    "EXT_DESCRIPTOR_INDEXING",
    {
        "name": "NV_SCISSOR_EXCLUSIVE",
        "struct_type": "EXCLUSIVE_SCISSOR_FEATURES_NV"
    },
    "KHR_SHADER_FLOAT16_INT8",
    "EXT_FRAGMENT_DENSITY_MAP",
    "KHR_FRAGMENT_SHADER_BARYCENTRIC",
    "EXT_INLINE_UNIFORM_BLOCK",
    "EXT_MEMORY_PRIORITY",
    "NV_MESH_SHADER",
    "KHR_MULTIVIEW",
    "NV_REPRESENTATIVE_FRAGMENT_TEST",
    "KHR_SAMPLER_YCBCR_CONVERSION",
    "EXT_SCALAR_BLOCK_LAYOUT",
    "KHR_SHADER_ATOMIC_INT64",
    "NV_SHADER_IMAGE_FOOTPRINT",
    "NV_SHADING_RATE_IMAGE",
    "EXT_TRANSFORM_FEEDBACK",
    "KHR_VARIABLE_POINTERS",
    "EXT_VERTEX_ATTRIBUTE_DIVISOR",
    "KHR_VULKAN_MEMORY_MODEL",
]


TEMPLATE="""\
// Automatically generated by make-features.py

static EXTENSIONS: [Extension; ${len(extensions)}] = [
% for e in extensions:
    Extension {
        name_bytes: vk::VK_${e.name}_EXTENSION_NAME,
        struct_size: mem::size_of::<vk::${e.struct}>(),
        struct_type: vk::${e.struct_type},
        features: &[
% for f in e.features:
            "${f}",
% endfor
        ],
    },
% endfor
];

const N_BASE_FEATURES: usize = ${len(base_features)};

static BASE_FEATURES: [&'static str; N_BASE_FEATURES] = [
% for f in base_features:
    "${f}",
% endfor
];
"""


class Extension:
    def __init__(self, name, struct, struct_type, features):
        self.name = name
        self.struct = struct
        self.struct_type = struct_type
        self.features = features


def capitalize_part(part):
    md = re.match(r'([0-9]*)(.*)', part)
    return md.group(1) + md.group(2).capitalize()


def extension_to_struct_name(ext):
    parts = ext.split("_")
    vendor = parts[0]
    rest = parts[1:]

    return ("VkPhysicalDevice" +
            "".join(capitalize_part(part) for part in rest) +
            "Features" +
            vendor)


def struct_to_regexp(struct):
    # Make the vendor in the struct name optional
    md = re.match(r'(.*?)([A-Z]+)$', struct)
    return re.compile(r'^typedef\s+struct\s+' +
                      re.escape(md.group(1)) +
                      r'(?:' + re.escape(md.group(2)) + ')?\s+' +
                      '{\s*$',
                      flags=re.MULTILINE)


def get_struct_features(header, struct):
    struct_re = struct_to_regexp(struct)
    md = struct_re.search(header)

    if md is None:
        raise Exception("Couldn't find extension {} in vulkan header".format(
            struct))

    header_tail = header[md.end() + 1 :]
    header_end = re.search(r'^}', header_tail, flags=re.MULTILINE).start()
    members = header_tail[:header_end]

    for line in members.splitlines():
        md = re.match(r'\s*VkStructureType\s+[A-Za-z]+\s*;\s*$', line)
        if md:
            continue
        md = re.match(r'\s*void\s*\*\s+pNext\s*;\s*$', line)
        if md:
            continue
        md = re.match(r'\s*VkBool32\s+([a-zA-Z][a-zA-Z0-9_]*)\s*;\s*$', line)
        if not md:
            raise Exception("Unknown member in struct: " + line)

        yield md.group(1)


def main():
    header = sys.stdin.read()

    extensions = []

    for ext in EXTENSIONS:
        if not isinstance(ext, dict):
            ext = { "name": ext }

        name = ext["name"]

        try:
            struct_type = ext["struct_type"]
        except KeyError:
            parts = name.split("_")
            struct_type = ("_".join(parts[1:]) + "_" +
                           "FEATURES_" +
                           parts[0])

        try:
            struct = ext["struct"]
        except KeyError:
            parts = struct_type.split("_")
            struct = ("VkPhysicalDevice" +
                      "".join(capitalize_part(part)
                              for part in parts[:-1]) +
                      parts[-1])

        struct_type_enum = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_" + struct_type

        features = list(get_struct_features(header, struct))
        extension = Extension(name, struct, struct_type_enum, features)
        extensions.append(extension)

    base_features = list(
        get_struct_features(header, "VkPhysicalDeviceFeaturesKHR")
    )

    # Validate that all of the feature names are unique
    all_features = [feature for extension in extensions
                    for feature in extension.features] + base_features

    feature_names = set()
    for feature in all_features:
        if feature in feature_names:
            raise Exception("Feature {} is not unique".format(feature))
        feature_names.add(feature)

    template = Template(TEMPLATE)
    print(template.render(extensions = extensions,
                          base_features = base_features))


if __name__ == '__main__':
    main()
