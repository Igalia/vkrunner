#!/usr/bin/env python

# Copyright (C) 2019 Intel Corporation

# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from __future__ import (
    absolute_import, division, print_function, unicode_literals
)

# This script is used to generate vr-feature.c from vulkan.h. It
# is not run automatically as part of the build process but if need be
# it can be used to update the file as follows:
#
# ./make-features.py < /usr/include/vulkan/vulkan.h > vr-features.c

import re
import sys
from mako.template import Template


EXTENSIONS = [
    "KHR_16BIT_STORAGE",
    "KHR_8BIT_STORAGE",
    {
        "name": "EXT_ASTC_DECODE_MODE",
        "struct": "VkPhysicalDeviceASTCDecodeFeaturesEXT",
        "struct_type": "ASTC_DECODE_FEATURES_EXT"
    },
    "EXT_BLEND_OPERATION_ADVANCED",
    "EXT_BUFFER_DEVICE_ADDRESS",
    "NV_COMPUTE_SHADER_DERIVATIVES",
    "EXT_CONDITIONAL_RENDERING",
    "NV_CORNER_SAMPLED_IMAGE",
    "EXT_DESCRIPTOR_INDEXING",
    {
        "name": "NV_SCISSOR_EXCLUSIVE",
        "struct_type": "EXCLUSIVE_SCISSOR_FEATURES_NV"
    },
    "KHR_SHADER_FLOAT16_INT8",
    "EXT_FRAGMENT_DENSITY_MAP",
    "KHR_FRAGMENT_SHADER_BARYCENTRIC",
    "EXT_INLINE_UNIFORM_BLOCK",
    "EXT_MEMORY_PRIORITY",
    "NV_MESH_SHADER",
    "KHR_MULTIVIEW",
    "NV_REPRESENTATIVE_FRAGMENT_TEST",
    "KHR_SAMPLER_YCBCR_CONVERSION",
    "EXT_SCALAR_BLOCK_LAYOUT",
    "KHR_SHADER_ATOMIC_INT64",
    "NV_SHADER_IMAGE_FOOTPRINT",
    "NV_SHADING_RATE_IMAGE",
    "EXT_TRANSFORM_FEEDBACK",
    "KHR_VARIABLE_POINTERS",
    "EXT_VERTEX_ATTRIBUTE_DIVISOR",
    "KHR_VULKAN_MEMORY_MODEL",
]

TEMPLATE="""\
/* Automatically generated by make-features.py */

#include "config.h"
#include <stddef.h>

#include "vr-feature.h"
#include "vr-vk.h"

% for e in extensions:
% if e.name:
#ifdef ${e.ext_name}
% if e.version:
#if ${e.version_var} >= ${e.version}
% endif
#define have_${e.name}
% endif
${e.storage}const struct vr_feature_offset
${e.var_name}[] = {
% for f in e.features:
        {
                .name = "${f}",
                .offset = offsetof(${e.struct}, ${f})
        },
% endfor
        { .name = NULL }
};
% if e.name:
% if e.version:
#else /* ${e.version_var} > ${e.version} */
#warning "The Vulkan headers are too old for ${e.ext_name}"
#endif
% endif
#else /* ${e.ext_name} */
#warning "The vulkan headers are missing ${e.ext_name}"
#endif
% endif

% endfor
const struct vr_feature_extension
vr_feature_extensions[] = {
% for e in extensions:
% if e.name:
#ifdef have_${e.name}
% endif
        {
                .name = ${e.ext_name},
                .struct_size = sizeof(${e.struct}),
                .struct_type = ${e.struct_type},
                .offsets = ${e.var_name}
        },
% if e.name:
#endif
% endif
% endfor
        { .struct_size = 0 }
};
"""


class Extension:
    def __init__(self, name, struct, struct_type, features, version=None):
        self.name = name
        self.struct = struct
        self.struct_type = struct_type
        self.features = features
        self.version = version

        if name is None:
            self.ext_name = "NULL"
            self.var_name = "vr_feature_base_offsets"
            self.storage = ""
        else:
            self.ext_name = 'VK_{}_EXTENSION_NAME'.format(name)
            self.var_name = "offsets_{}".format(name)
            self.storage = "static "

        if version is not None:
            self.version_var = 'VK_{}_SPEC_VERSION'.format(name)


def capitalize_part(part):
    md = re.match(r'([0-9]*)(.*)', part)
    return md.group(1) + md.group(2).capitalize()


def extension_to_struct_name(ext):
    parts = ext.split("_")
    vendor = parts[0]
    rest = parts[1:]

    return ("VkPhysicalDevice" +
            "".join(capitalize_part(part) for part in rest) +
            "Features" +
            vendor)


def struct_to_regexp(struct):
    # Make the vendor in the struct name optional
    md = re.match(r'(.*?)([A-Z]+)$', struct)
    return re.compile(r'^typedef\s+struct\s+' +
                      re.escape(md.group(1)) +
                      r'(?:' + re.escape(md.group(2)) + ')?\s+' +
                      '{\s*$',
                      flags=re.MULTILINE)


def get_struct_features(header, struct):
    struct_re = struct_to_regexp(struct)
    md = struct_re.search(header)

    if md is None:
        raise Exception("Couldn't find extension {} in vulkan header".format(
            struct))

    header_tail = header[md.end() + 1 :]
    header_end = re.search(r'^}', header_tail, flags=re.MULTILINE).start()
    members = header_tail[:header_end]

    for line in members.splitlines():
        md = re.match(r'\s*VkStructureType\s+[A-Za-z]+\s*;\s*$', line)
        if md:
            continue
        md = re.match(r'\s*void\s*\*\s+pNext\s*;\s*$', line)
        if md:
            continue
        md = re.match(r'\s*VkBool32\s+([a-zA-Z][a-zA-Z0-9_]*)\s*;\s*$', line)
        if not md:
            raise Exception("Unknown member in struct: " + line)

        yield md.group(1)


def main():
    header = sys.stdin.read()

    extensions = []

    for ext in EXTENSIONS:
        if not isinstance(ext, dict):
            ext = { "name": ext }

        name = ext["name"]

        try:
            struct_type = ext["struct_type"]
        except KeyError:
            parts = name.split("_")
            struct_type = ("_".join(parts[1:]) + "_" +
                           "FEATURES_" +
                           parts[0])

        try:
            struct = ext["struct"]
        except KeyError:
            parts = struct_type.split("_")
            struct = ("VkPhysicalDevice" +
                      "".join(capitalize_part(part)
                              for part in parts[:-1]) +
                      parts[-1])

        version = ext.get("version", None)

        struct_type_enum = "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_" + struct_type

        features = list(get_struct_features(header, struct))
        extension = Extension(name, struct, struct_type_enum, features, version)
        extensions.append(extension)

    base_features = get_struct_features(header, "VkPhysicalDeviceFeaturesKHR")
    extensions.append(Extension(None,
                                "VkPhysicalDeviceFeatures",
                                "0",
                                list(base_features)))

    # Validate that all of the feature names are unique
    feature_names = set()
    for ext in extensions:
        for feature in ext.features:
            if feature in feature_names:
                raise Exception("Feature {} is not unique".format(feature))
            feature_names.add(feature)

    template = Template(TEMPLATE)
    print(template.render(extensions = extensions))


if __name__ == '__main__':
    main()
