[require]
geometryShader

[vertex shader]
#version 450

/* The vertex shader positions a point at the top-left corner of every
 * grid position. These will be expanded into rectangles by the
 * geometry shader.
 */

const int GRID_SIZE = 16;

void
main()
{
        gl_Position = vec4(vec2(gl_VertexIndex % GRID_SIZE,
                                gl_VertexIndex / GRID_SIZE) *
                           2.0 / GRID_SIZE - 1.0,
                           0.0,
                           1.0);
}

[geometry shader]
#version 450

/* The geometry shader takes the points from the vertex shader and
 * reads from the buffer containing the grid of cells. If the cell is
 * alive then the point is expanded into quad using a triangle strip.
 */

const int GRID_SIZE = 16;

layout(points) in;
layout(triangle_strip, max_vertices = 4) out;

layout(binding = 0, std140) buffer state {
        uint board[];
};

layout(push_constant) uniform pcs {
        uint frame_num;
};

void
main()
{
        int in_offset;

        /* The buffer is big enough to hold two copies of the grid so
         * that we can do double buffering to calculate the next frame
         * while reading the previous frame. Therefore we alternate
         * between the two halves of the buffer at each frame.
         */
        if (bool(frame_num & 1))
                in_offset = 0;
        else
                in_offset = GRID_SIZE * GRID_SIZE;

        /* Don’t generate anything for this position if the cell is
         * dead.
         */
        if (board[in_offset + gl_PrimitiveIDIn] == 0)
                return;

        /* Otherwise generate four vertices to form a quad */
        for (int y = 0; y < 2; y++) {
                for (int x = 0; x < 2; x++) {
                        gl_Position = vec4(gl_in[0].gl_Position.xy +
                                           vec2(x, y) / GRID_SIZE * 2.0,
                                           0.0,
                                           1.0);
                        EmitVertex();
                }
        }

        EndPrimitive();
}

[fragment shader]
#version 450

layout(location = 0) out vec4 color_out;

void
main()
{
        color_out = vec4(1.0);
}

[compute shader]
#version 450

const int GRID_SIZE = 16;

layout(binding = 0, std140) buffer state {
        uint board[];
};

layout(push_constant) uniform pcs {
        uint frame_num;
};

int in_offset;
int out_offset;

bool
is_alive(ivec2 pos)
{
        /* Wrap the position around the grid */
        pos &= GRID_SIZE - 1;

        return bool(board[in_offset + pos.y * GRID_SIZE + pos.x]);
}

void
main()
{
        if (bool(frame_num & 1)) {
                in_offset = GRID_SIZE * GRID_SIZE;
                out_offset = 0;
        } else {
                in_offset = 0;
                out_offset = GRID_SIZE * GRID_SIZE;
        }

        uint count = 0;

        for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                        if (x == 0 && y == 0)
                                continue;
                        if (is_alive(ivec2(gl_WorkGroupID.xy) + ivec2(x, y)))
                                count++;
                }
        }

        bool result;

        if (count < 2)
                result = false;
        else if (count == 2)
                result = is_alive(ivec2(gl_WorkGroupID.xy));
        else if (count == 3)
                result = true;
        else
                result = false;

        board[out_offset + gl_WorkGroupID.y * GRID_SIZE + gl_WorkGroupID.x] =
                uint(result);
}

[test init]
ssbo 0 8192

ssbo 0 subdata uint 0     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 256   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 512   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 768   0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 1024  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 1280  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 1536  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 1792  0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0
ssbo 0 subdata uint 2048  0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 2304  0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0
ssbo 0 subdata uint 2560  0 0 0 0 0 1 1 1 1 0 0 0 0 0 0 0
ssbo 0 subdata uint 2816  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 3072  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 3328  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 3584  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ssbo 0 subdata uint 3840  0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

[test]

clear

uniform frame_num 0
compute 16 16 1

# This is a dummy command to make sure the compute shader finishes
# before rendering. If VkRunner had a barrier command this wouldn’t be
# necessary.
probe ssbo uint 0 0 >= 0
        
uniform frame_num 0
draw arrays POINT_LIST 0 256
